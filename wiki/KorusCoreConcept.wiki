= Korus Core Concept =

[http://img180.imageshack.us/img180/7681/korus.jpg]

*Figure: Comparison between Standard and Korus Request Execution in an HTTP Environment*

The figure above is divided into two parts. The first part shows the Standard Web Execution and the second part shows a Korus execution. Let us first take the first part and see how a standard request is being typically served.


=== 1. Standard Execution ===

Whenever a request is being received it is served using a thread (most probably from a Threadpool). A sequence of tasks are being performed to serve a complete request and response is generated. The tasks are generally sequential in nature and every time the task is performed probably a new thread  will take the control.


=== 2. Korus Execution ===

Korus-process - Single Unit of Code Execution which is stateless in nature. Extremely light weight as compared to threads.

The sub-tasks of a Standard Execution can be transformed into Korus Processes which can now execute independently. Here, we have one(or very few) threads serving the requests. Korus Process are asynchronous in nature and here context switching happens between different pieces of code instead of Thread context switching. 



*Table: Comparision between Traditional Thread Model and Korus - Code Context Switching*

|| *Traditional Thread Model* || *Korus - Code Context Switching* ||
|| One Thread manages one request || Very few  (1-3) execution threads ||
|| Threads are allocated from a server-managed thread pool || Korus does the context switching between pieces of Code ||
|| Memory consumption increases with the number of HTTP connections || Reduces the context switching overhead ||
|| Problems with deadlock, starvation, race condition etc|| No deadlocks and thread related issues ||
