#labels Phase-Deploy,Featured
This page provides you a step-by-step to get started with korus

= 1. Getting Korus =

The latest stable version of Korus is available from the Korus web page http://code.google.com/p/korus/source/checkout 

For the current version of Korus, you will also need a JDK installed on your system, version 1.5 or later required, 1.5 or later strongly recommended. 

The binary distribution of  consists of the following directory layout:
{{{
 Korus
   +--- Plan
   |
   +--- Product // contains API Files
   |      |
   |      +--- octopus
   |              |
   |              +--- bin        // Compiled Code
   |              +--- build      // Build Scripts
   |              +--- dst        
   |              +--- jar        // Compiled Jar
   |              +--- javadoc    // Java Documentation
   |              +--- src        // Source Files
   |
   +--- Support  // Contains the supporting files
   |      |
   |      +--- ant
   |      +--- legal
   |      +--- userdocs
   |
   +--- Test // contains Test Classes
          |
          +--- bin        // Compiled Code of Test Classes
          +--- lib        // Libraries needed by Test Classes
          +--- report
          +--- src        // Source Files for Test Classes
   
}}}

== 1.3 Checkout Korus ==
===1.3.1 ===

Use an SVN client and checkout korus
{{{
  $ svn checkout http://korus.googlecode.com/svn/trunk/ korus-read-only
}}}

== 1.4 Install Ant ==

Install ant from [http://ant.apache.org/ here]


== 1.5 Building Korus ==

=== 1.5.1 Windows ===

Go to the Korus --> Product --> octopus Folder

{{{
 > cd build
 > ant clean
 > ant compile
 > ant jar
}}}

This will generate the jar in your Korus --> Product --> octopus --> jar Folder. You can then either put the JAR of Korus to your preferred directory or put the jars on the system CLASSPATH. 

If you prefer to the source edition, you can find it in the Korus --> Product --> octopus --> src Folder. 

For only using the compiled classes you need to :

{{{
 > cd build
 > ant clean
 > ant compile
}}}

This will compile the Java classes and into the Korus --> Product --> octopus --> classes Folder.

Compile it using the java compile commands and you can start using it in your Project.

=== 1.5.2 Unix ===

Go to the Korus --> Product --> octopus Folder

{{{
 $ cd build
 $ ./ant.sh clean
 $ ./ant.sh recompile
 $ ./ant.sh jar
}}}

This will generate the jar in your Korus --> Product --> octopus --> jar Folder. You can then either put the JAR of Korus to your preferred directory or put the jars on the system CLASSPATH. 

If you prefer to the source edition, you can find it in the Korus --> Product --> octopus --> src Folder. 

For only using the compiled classes you need to :

{{{
 $ cd build
 $ ./ant.sh clean
 $ ./ant.sh compile
}}}

This will compile the Java classes and into the Korus --> Product --> octopus --> classes Folder.

Compile it using the java compile commands and you can start using it in your Project.

----

= 2. Using Korus =

== 2.1 Parallel For Concepts ==

[http://code.google.com/p/korus/wiki/ParallelFor Click Here] for a sample implementation of _ ParallelFor _.

=== 2.1.1 BlockedRange ===

It is a single unit of block that can be executed in a single iteration. Suppose, we have an iteration space from 0 to n. Then, an object of blocked range will be constructed whose first argument will be the start of the iteration and second argument will be end of the iteration. A third argument _ grainSize _ will also have to be specified which breaks these _ BlockedRanges _ into units which can be executed by a single core or processor.
{{{
BlockedRange range= new BlockedRange(1,10000,1250);
}}}

will finally construct  10000/1250 = 8 _ BlockedRanges _

=== 2.1.2 GrainSize ===

The _grainSize_ enables you to decide the degree of parallelization you want achieve while running your program. It helps in dividing the task into subranges. Every subrange has some cost associated to it. A smaller _grainsize_ may also result in excessive overhead and may hinder useful work. So, the size of the _grainsize_ has to be chosen very carefully. 

=== 2.1.3 ParallelTask ===
In order to write a parallel function in a class, it has to extend a _ ParallelTask _. A _ ParallelTask _ bounds the user to implement a _service()_ and a _summarize()_ method. The code written inside the for block of a serial function comes in the for block of the _service()_ method. A _summarize()_ block is written in order to summarize all the intermediate results. 

[http://code.google.com/p/korus/wiki/ParallelFor Click Here] for a sample implementation of _ ParallelFor _. 

== 2.2 Pipeline Concepts==

[http://code.google.com/p/korus/wiki/Pipeline Click Here] for a sample implementation of a _ Pipeline _ .

=== 2.2.1 Pipeline ===
The term pipeline refers to the fact that each step is carrying data at once (like water), and each step is connected to the next (like the links of a pipe.)

- Wikipedia

The idea of a pipeline is to split the processing of data into number of steps. Each of these steps will run independently, process data and put the data in its _ outputQueue _. The _ outputQueue _ of the first step will be the _ inputQueue _ for the consecutive step. The first step will have no _ inputQueue _ and the last step will have no _ outputQueue _. 

=== 2.2.2 PipelineTask  ===

In order to implement pipeline, stages or pipeline tasks need to be written. These tasks are written by extending a _ PipelineTask _ and overriding its _ service() _ method.

These tasks are then added to the pipeline, paired (in order to decide the order of tasks) and executed. A pipeline task just has a _ service() _ method and no _ summarize() _ method. 

[http://code.google.com/p/korus/wiki/Pipeline Click Here] for a sample implementation of a _ Pipeline _ .