Describes the usage and functionality of Pipeline construct

== Introduction ==
Pipeline allows you to model your sequential independent task parallely. For example, a file transformation job can be modeled as 3 tasks of reading ,transforming and writing the file. The tasks communicate to each other via one-way intermediate queues.

== Example : !FileTransformationPipeline ==

Pipelining is very useful when the output of one task serves as an input to the succeeding task. Lets, understand this with help of an example. Suppose, we want to:

 # Read a file form the disk.
 ## Transform the data in the file (Say, convert all the characters to uppercase).
 ## Write the file back to the disk .

In normal circumstances this will be performed sequentially. Lets understand this better with the help of a graphics.

[http://code.google.com/ http://korus.googlecode.com/files/pipeline_seq.JPG]

As we can see that at any given time only one core is utilized properly and rest of the CPUs are idle. The performance of such programs can be substantially improved by using a Parallel Pipeline. The functionality of a Parallel Pipeline is illustrated below.

[http://code.google.com/ http://korus.googlecode.com/files/pipeline_parallel.JPG]

Each pipelined operation is termed as a Task. A task is nothing but performing the entire operation into chunks. For example, instead of reading a complete file and then applying transformation to it. We will read a chunk of data and then apply transformation to that chunk and similarly write that chunk back to the disk. Once a chunk is been processed, its placed into an intermediate queue so that it can be now accessed by the consecutive tasks.

For achieving the above functionality, we need to define three Tasks extending !PipelineTask.

 # !ReadTask
{{{
// Extend the PipelineTask
public class ReadTask extends PipelineTask {

// No argument constructor of the ReadTask
public ReadTask() {
}
   // Overide the service method present in PipelineTask
   public void service() 
   {
      // Point the file to be read 
      File f = new File("c:/testFile.txt");
     
      // Since this is the first Task to be executed, it will just have
      // one outputQueue and no inputQueue.
      OctopusQueue<Object> outputQ = this.getOutputQueue();
      try 
      {
         BufferedReader reader = new BufferedReader(new FileReader(f));
         String line = null;
         while ((line = reader.readLine()) != null) 
         {
            // read lines and add it to the Queue
            outputQ.add(line);
         }
      } catch (FileNotFoundException e) 
      {
         e.printStackTrace();
      } catch (IOException e) 
      {
         e.printStackTrace();
      }
   }
}
}}}
 # !TransformTask
{{{
public class TransformTask extends PipelineTask {

   // No argument constructor of the TransformTask 
   public TransformTask() 
   {
   }
   
   // Overide the service method present in PipelineTask
   public void service() 
   {
      // This task has both a preceding task and a succeeding task hence
      // it will have an inputQueue as well as an outputQueue. InputQueue
      // of this task is outPutQueue of the preceding task and outputQueue
      // of this task is the inputQueue for the succeeding
      OctopusQueue<Object> inputQ = this.getInputQueue();
      OctopusQueue<Object> outputQ = this.getOutputQueue();
      
      try 
      {
         // the previous task should be started
         this.getPreviousTask().hasStarted();
         
         // Condition 1: input queue is not empty 
         while (inputQ.isEmpty() == false) 
         {
            // remove the element from the Queue
            String str = (String) inputQ.remove();
            // Do the transformation
            str = str.toUpperCase();
            // Put it back in the outputQueue
            outputQ.put(str);
         }
         
         // Condition 2: previous task should not be over
         while (this.getPreviousTask().isDone() == false
                                || inputQ.isEmpty() == false) 
         {
            if (inputQ.isEmpty() == false) 
            {
               String str = (String) inputQ.take();
               str = str.toUpperCase();
               outputQ.put(str);
            }
         }
      } 
      catch (Exception e) 
      {
         e.printStackTrace();
      }
   }
}
}}}
 # WriteTask
{{{
public class WriteTask extends PipelineTask {

   // No argument constructor of the WriteTask 
   public WriteTask() 
   {
   }
   
   // Overide the service method present in PipelineTask
   public void service() 
   {
      // Since this is the last Task to be executed, it will just have
      // one inputQueue and no outputQueue.
      OctopusQueue<Object> inputQ = this.getInputQueue();
      BufferedWriter out = null;
      try 
      {
         // output file
         out = new BufferedWriter(new FileWriter("C:\\writeFile.txt"));
         // the previous task should be started
         this.getPreviousTask().hasStarted();
         
         // Condition 1: input queue is not empty
         while (inputQ.isEmpty() == false) 
         {
            // read date from the Queue
            String str = (String) inputQ.remove();
            // write it using the BufferedWriter
            out.write(str + "\r" + "\n");
         }
         // Condition 2: previous task should not be over
         while (this.getPreviousTask().isDone() == false
                              || inputQ.isEmpty() == false) 
         {
            String str = null;
            if (inputQ.isEmpty() == false) 
            {
               // read date from the Queue
               str = (String) inputQ.remove();
               // write it using the BufferedWriter
               out.write(str + "\r" + "\n");
            }
         }
      } 
      catch (Exception e) 
      {
         e.printStackTrace();
      } 
      finally 
      {
         try 
         {
            out.close();
         } 
         catch (IOException e) 
         {
            e.printStackTrace();
         }
      }
   }
}
}}}

And finally invoke these Tasks one by one:

{{{
// Create a Pipeline
Pipeline pipeline = new Pipeline("Pipeline Test");

// Create objects Tasks which extend PipelineTasks
ReadTask readTask = new ReadTask();
TransformTask transformTask = new TransformTask();
WriteTask writeTask = new WriteTask();

// Add these tasks to the pipeline
pipeline.add(readTask);
pipeline.add(transformTask);
pipeline.add(writeTask);

// Join these tasks in order to know the order of execution of the tasks
pipeline.join(readTask, transformTask);
pipeline.join(transformTask, writeTask);

// Execute the Pipeline
pipeline.execute();

// Clean up the Pipeline
pipeline.cleanup(); 

}}}