Describes the usage and definition of ParallelFor construct
==Introduction ==
Parallel For is a parallel version of a for loop which executes the loop parallely and tries to utilize more number of cores for lower turnaround time. A parallel for loop takes in a range which determines

== Example : Factorial ==
Suppose we want to calculate a factorial of a very big number. Using parallel for will not be as simple as to just replacing the for construct by a parallelFor. But its not that difficult too. Just by tweak the program a little bit here and there, we will have parallelFor working. Lets suppose that we want to calculate a factorial of a very big number. A simple program calculate a factorial could go like this :

{{{
  public class SerialFactorial 
  {
      public static void main(String[] args) 
      {
          for (i=1; i<=10000; i++) 
          {
             // write the logic to calculate factorial
             ...
          }
      }
  }
}}}

If we add the logic inside the loop and the necessary imports. The code will look like this:

{{{
import java.math.BigInteger;

public class SerialFactorial 
{
   public static void main(String[] args) 
   {
      // Set the fact variable to 1 initially.
      BigInteger result = BigInteger.ONE;
      int i = 1;

      for (i=1; i<=10000; i++) 
      {
         // write the logic to calculate factorial
         result = result.multiply(BigInteger.valueOf(i)); 
      }
   }
}
}}}

This program will run sequentially and only a single core will be utilized no matter how many core machine we put in to improve the performance . Suppose we want to run this program so that it utilize all the cores, we need to perform certain changes.

 # Create a class containing this logic which:
 * extends ParallelTask,
 * overrides a service() and summarize() methods
 * iterate the loop from begin of the range through end of the range and set the result

{{{
public class ParallelFactorial extends ParallelTask {

   // implement a service method
   public void service() 
   {
      // iterate the loop from begin to end over a given range 
      for (int i = this.getRange().getBegin(); i <= this.getRange().getEnd(); i++) 
      {
         // write the logic to calculate factorial
         ...
      }

      // set the intermediate result in a variable to be returned 
      // for each iteration
      this.setResult(fact);
   }

   // implement a summarize method.
   public Object summarize(List<Object> intermediateResults)
   {

      // iterate over the intermediate results and summarize the results 
      for (Iterator iter = intermediateResults.iterator(); iter.hasNext();) 
      {
         // logic to calculate the final result
         ...
      }

      // return the final result
      return finalfact;
   }
} 

}}}
If we add the logic inside the loop and the necessary imports. The code will look like this:

{{{
public class ParallelFactorial extends ParallelTask {


private static BigInteger finalfact = BigInteger.ONE;
   // implement a constructor.
   public ParallelFactorial(BlockedRange range)
   {
      super(range);
   }

   // implement a service method
   public void service() 
   {
      // Set the fact variable to 1 initially.
      BigInteger fact =  BigInteger.ONE;

      // iterate the loop from begin to end over a given range 
      for (int i = this.getRange().getBegin(); i <= this.getRange().getEnd(); i++) 
      {
         // write the logic to calculate factorial
         fact = fact.multiply(BigInteger.valueOf(i));
      }

      // set the intermediate result in a variable to be returned 
      // for each iteration
      this.setResult(fact); 
   }

   // implement a summarize method.
   public Object summarize(List<Object> intermediateResults)
   {
      BigInteger factorial =  BigInteger.ONE;
   
      // iterate over the intermediate results and summarize the results 
      for (Iterator iter = intermediateResults.iterator(); iter.hasNext();) 
      {
         factorial = (BigInteger)iter.next();
         finalfact = finalfact.multiply(factorial);
      }

      // return the final result
      return finalfact;
   }
}    

}}}
Create a class which will use this class and to use it we add the following code.
{{{
// Create an object of the construct to be used
Parallel parallel = new Parallel();

// specify begin, end and grainSize according to the machine
BlockedRange range= new BlockedRange(1,10000,1250);

// Create an object of a class extending ParallelTask Class
ParallelFactorial pf = new ParallelFactorial(range);

// pass the object to the parallelFor construct
Object obj = parallel.parallelFor(pf);
}}}

If we add the logic inside the loop and the necessary imports. The code will look like this:

{{{
import com.impetus.octopus.BlockedRange;
import com.impetus.octopus.Parallel;

public class ParallelFactorialTest 
{
   // Simple demo to demonstrate Parallel For construct 

   public static void main(String[] args) 
   {
      // Create an object of the construct to be used
      Parallel parallel = new Parallel();

      // specify begin, end and grainSize according to the machine
      BlockedRange range= new BlockedRange(1,10000,1250);

      // Create an object of a class extending ParallelTask Class
      ParallelFactorial pf = new ParallelFactorial(range);

      try
      {

         // pass the object to the parallelFor construct
         Object obj = parallel.parallelFor(pf);
      }
      catch (CloneNotSupportedException e)
      {
         e.printStackTrace();
      }
      catch (Exception e)
      {
         e.printStackTrace();
      } 
   }
} 
}}}